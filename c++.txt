=============================================
//ссылки
//ссылки никогда не бывают void и NULL и всегда проинициализированы
//к ссылкам не применима адресная арфиметика
void f(int &x)
{
x=0;
}

main()
{
int a;
f(a);
return 0;
}
=============================================
// в памяти создается динамический массив, который после работы необходимо закрыть
// аналог malloc и free из С
int *a = new int[100]
...;
delete []a;
=============================================
// вложенная функция, которая будет вставлять свой код, вместо обращения к ней
//(так быстрее и лучше всего использовать в циклах)
// аналог #define из С (его нужно использовать в простых выражениях, а inline в сложных)
inline int func(int a, int b)
{
....;
}
=============================================
//перегрузка функции
//для перегрузки функции необходимо чтобы сигнатура имела хоть какое то отличие
//тип возвращаемых данных нельзя использовать для перегрузки 
int sum (int, int);
int sum (int, int, int);
=============================================
//значения по умолчанию 
//эти значения должны стоять в конце функции, чтобы избежать ошибок и сложностей 
void calc(int a,float b, float c=.5, bool d=true)
{
...;
}
=============================================
//пространство имен
// так как написано много классов, стало принято использовать namespace
//что означает что ты используешь определенную функцию данной бибилиотеки
std::cout //либо так
using namespace std; //либо уже так, ты сообщаешь что работаешь с пространством std
cout
=============================================
//Если у функции нет аргументов нужно это указать
int main(void)
{
...;
return 0;
}
=============================================
//Подклчение библиотек
//Если библиотека с++, то .h не нужна
// А библиотека С, нужна
#include <iostream> // C++
#include <math.h> // C
=============================================
//классы
//законы ООП :
//инкапсуляция (закрытость) - внутренняя реализация класса должна быть закрыта от потребителя
class TCircle //классы принято называть с большой буквы
{
public:   //раздел доступный всем

private:  //закрытый раздел класса, доступно только в процессе создания класса и не доступно извне

protected: // необходимо при наследовании от нашего класса
};
=============================================
//агригирование - когда класс включает в себя использование других классов
class TCircle
{
public:
void SetR(float);
float GetR(void);
................;
TPen pen;
TBrush brush;
private:
................;
};
=============================================
//стандартный системный указатель на объект класса, который когда-нибудь где нибудь появится
this // будет определен только когда на основе нашего класса появятся объекты

class A
{
.....;
};

A a,b,c // this указывает на объекты нашего класса
=============================================
//дружественные классы
//они имеют доступ в private
//ограничение по дружественности:
//дружественность не является транзитивной(друг моего друга не мой друг)
//дружественность не обращается (если А дружит с В , это не значит что В дружит с А)
//дружественность не наследуется
class A
{
public:
void f(void);
}

class B
{
public:
friend void A::f(void);// класс А имеет доступ внутрь класса Б (только по методу f)
private:
.......;
}
=============================================
//конструкторы
//конструктор запускается тогда, когда объект в памяти уже размещен
//конструктор решает задачу инициализации класса
//конструктор это метод класса и называется как класс
//у конструкора никогда не указывают возвращаемое значение
//конструктор нельзя вызвать явно
//конструкторов может быть много и они называются одинакого(перегруженные)

class TTest
{
public:
    TTest(){     //конструктор умолчаний(тоесть при создании объекта класса присваивает значения)
        x=0;
    }
private:
    int x;
};

//если необходимо создать указатель на объект класса, то так
TTest *test = new TTest(); //обращение к консрутору

// а так бы выглядел второй конструктор для примера выше
TTest(int x)
    {
        SetX(x);
    }

//а указатель на него 
TTest *test2 = new TTest (101)
=============================================
//конструктор по умолчанию
//код класса дополняется автоматически в том случае если нет никаких других конструкторов
=============================================
//существует третий  вид конструторов 

TTest(): x(0) {} // так же приравняет поле x к нулю перед выполнением кода в теле
TTest(int x): x(x) {} // или так x нашего класса присваивается значение int x из аргумента
=============================================
// четвертый вид конструкторов 
//конструктор копирования
// объект класса можно передавать в функцию только по ссылке
// а чтобы создать копию класса необходим конструктор копирования(он есть всегда)
// а его аргумент это всегда константная ссылка(обращаемся к объекту, но его нельзя изменить)

TTest (const TTest &);

// если мы работаем с динамическими объектами, нам нужно описать конструктор копирования
// а если объекты статические, хватит стандартного
=============================================
//деструкторы 
// нужны для классов с динамической памятью, чтобы ее освободить
~TTest() {}
=============================================
//Статические элементы
//Можно объявить внутри класса и переменная будет храниться в оперативной памяти один раз 
// и не будет создаваться много раз для каждого объекта класса

 static int a;

//для использования статическую переменную необходимо инициализировать вне класса
int сlass:: a;
=============================================
//Статические функции
//работают только со статическими переменными
// и теперь можно вызывать функцию класса не привязываясь к объекту класса
static void func(int a) { class::a = a;}
//по идее это глобальные функции и переменные защищенные инкапсуляцией
=============================================
// если поле класса public static то это просто глобальная переменная
=============================================
//константные поля класса
//проинициализировать их можно  в коде класса
static const float k=2;
// а если так 
const int x; // то их необходимо инициализировать с обращением  к конструктору
TTset() : x(0){}
=============================================
//константные методы 
void func(void) const;// при объявлении функции такой синтаксис и так же надо в описании добавить const
// константный метод гарантированно не меняет ничего в классе
// если есть константные объекты, работать с ними можно только такими функциями
=============================================
// оператор volatile 
// является обратным к const, позволяет сделать const данные модифицируемыми
// например если данные сonst, то функцию можно определить volatile и она изменит данные
 